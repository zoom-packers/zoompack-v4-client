import {BasicDataHolder} from "../selfWritingJson";

import {NbtStructure, ReplaceBlockCommand, ReplaceEntityCommand, ReplaceLootTableCommand} from "./nbtStructure";
import {StructureSet} from "./structureSet";
import {Structure} from "./structure";
import {TemplatePool} from "./templatePool";
import {loadJsonFromPath, navigateUpUntilTargetFolder, removeNamespace} from "../utils";
import {findJigsawBlocks, readNbtFile, readNbtFromBuffer} from "../nbt/util";
import {Biome} from "./biome";
import path from "path";
import {ResourceLocation} from "../types";
import {
    STRUCTURE_JSON_REGISTRY,
    STRUCTURE_NBT_REGISTRY,
    STRUCTURE_SET_JSON_REGISTRY,
    TEMPLATE_POOL_REGISTRY
} from "../vfs/vfs";

export class StructureDefinition extends BasicDataHolder<StructureDefinition> {
    structureSet: StructureSet;
    structures: Structure[] = [];
    nbts: NbtStructure[] = [];

    constructor(name: string = "", namespace: string = "") {
        super();
        this.internalName = name;
        this.internalNamespace = namespace
    }

    async build() {
        console.info(`Building structure ${this.internalNamespace}:${this.internalName}`)
        this.popNameAndNamepace();
        this.structures?.forEach(structure => {
            if (structure.template_pools?.length === 0) {
                const pool = new TemplatePool().withNamespace(this.internalNamespace).withName(structure.internalName).withStructure(`${structure.internalNamespace}:${structure.internalName}`);
                pool.autogenerated = true;
                structure.template_pools = [pool];
            }
        });
        this.popNameAndNamepace();
        for (const nbt of this.nbts) {
            await nbt.build();
        }
    }

    private popNameAndNamepace() {
        this.structures?.forEach(structure => {
            structure.withNamespace(this.internalNamespace);
            structure?.template_pools?.forEach(pool => {
                if (pool.autogenerated) {
                    pool.withNamespace(this.internalNamespace)
                }
            });
            if (structure.internalName === "") {
                structure.withName(this.internalName);
                structure?.template_pools?.forEach(pool => {
                    if (pool.autogenerated) {
                        pool.withName(this.internalName)
                    }
                });
            }
            this.structureSet.withStructure(structure);
        });
        this.structureSet.withNamespace(this.internalNamespace).withName(this.internalName);
        this.nbts?.forEach(nbt => {
            nbt.withNamespace(this.internalNamespace)
            if (nbt.internalName === "") {
                nbt.withName(this.internalName);
            }
        });
    }

    async fromResourceLocation(rl: ResourceLocation) {
        console.info(`Started processing structure set ${rl}`)
        this.structureSet = await (new StructureSet().fromResourceLocation(STRUCTURE_SET_JSON_REGISTRY, rl))
        if (!this.structureSet) {
            debugger;
        }
        this.structureSet.withNamespace(this.internalNamespace).withName(this.internalName);
        for (const structureEntry of this.structureSet.structures) {
            const structure = await (new Structure().fromResourceLocation(STRUCTURE_JSON_REGISTRY, structureEntry.structure));
            this.structures.push(structure);
            if (structure.type === "minecraft:jigsaw" || !!structure.start_pool) {
                const pool = await (new TemplatePool().fromResourceLocation(TEMPLATE_POOL_REGISTRY, structure.start_pool));
                pool.withNamespace(this.internalNamespace).withName(this.internalName + '_' + removeNamespace(structure.start_pool));
                structure.template_pools = [pool];
                await this.traversePool(pool, structure);
                structure.start_pool = this.internalNamespace + ':' + this.internalName + '_' + structure.start_pool.split(':')[1];
            }
            else {
                console.warn(`Structure ${structureEntry.structure} has no start_pool. Might be a dynamic structure. Please check to make sure.`)
            }
            structure.withNamespace(this.internalNamespace).withName(removeNamespace(structureEntry.structure));
            structureEntry.structure = this.internalNamespace + ":" + structureEntry.structure.split(":")[1];
        }
        return this;
    }

    private async traversePool(pool: TemplatePool, structure: Structure) {
        const poolElements = pool.elements;
        for (const element of poolElements) {
            if (!!element.element.processors && !!element.element.processors.endsWith && element.element.processors.endsWith('empty')) {
                continue;
            }
            if (element.element.element_type === "minecraft:single_pool_element" || element.element.element_type === "minecraft:legacy_single_pool_element") {
                await this.processElement(element.element, structure);
            } else if (element.element.element_type === "minecraft:list_pool_element") {
                for (const listElement of element.element.elements) {
                    await this.processElement(listElement, structure);
                }
            }
        }
    }

    private async processElement(element, structure: Structure) {
        console.log(`Started processing element: ${element.location}`);
        const originalLocation = element.location;

        const nbt = new NbtStructure().withResourceLocation(originalLocation);
        const fileGetter = await STRUCTURE_NBT_REGISTRY.get(originalLocation);
        if (!fileGetter) {
            console.error(`Could not find structure nbt for ${originalLocation}. Skipping`)
            return;
        }
        const buffer = fileGetter();
        const data = await readNbtFromBuffer(buffer as Buffer);
        if (data.parsed === null && data.type === null) {
            console.error(`Something went wrong. An NBT file would've been expected for ${originalLocation}, but nothing has been found`)
            return;
        }
        nbt.data = data.parsed;
        nbt.type = data.type;
        const jigsaws = findJigsawBlocks(data.parsed);
        for (const jigsaw of jigsaws) {
            const jigsawPoolId = jigsaw.nbt.value.pool.value;
            jigsaw.nbt.value.pool.value = this.internalNamespace + ":" + this.internalName + '_' + jigsawPoolId.split(":")[1];
            if (structure.template_pools.some(p => p.internalName === this.internalName + '_' + removeNamespace(jigsawPoolId))) {
                continue;
            }
            if (jigsawPoolId === "minecraft:empty" || jigsawPoolId === "minecraft:") {
                continue;
            }
            const jigsawPool = await (new TemplatePool().fromResourceLocation(TEMPLATE_POOL_REGISTRY, jigsawPoolId));
            if (!!jigsawPool) {
                jigsawPool.withNamespace(this.internalNamespace).withName(this.internalName + '_' + removeNamespace(jigsawPoolId));
                structure.template_pools.push(jigsawPool);
                await this.traversePool(jigsawPool, structure);
            }
        }
        this.nbts.push(nbt);
        nbt.withNamespace(this.internalNamespace).withName(this.internalName + '_' + removeNamespace(element.location));
        element.location = this.internalNamespace + ":" + this.internalName + '_' + element.location.split(":")[1];
        console.log(`Processed element: ${element.location}`);
    }

    afterBuild() {
        this.structures.forEach(structure => structure.afterBuild());
    }

    withNamespace(namespace: string): StructureDefinition {
        this.nbts?.forEach(nbt => nbt.withNamespace(namespace));
        return super.withNamespace(namespace);
    }

    withNbt(nbt: NbtStructure) {
        this.nbts.push(nbt);
        return this;
    }

    withStuctureSetJson(structureSet: StructureSet) {
        this.structureSet = structureSet;
        return this;
    }

    withStructureJson(structure: Structure) {
        this.structures.push(structure);
        return this;
    }

    withStructureJsons(structures: Structure[]) {
        this.structures = [...this.structures, ...structures];
        return
    }

    replaceBlock(command: ReplaceBlockCommand) {
        this.nbts.forEach(nbt => nbt.replaceBlock(command));
        return this;
    }

    replaceBlocks(commands: ReplaceBlockCommand[]) {
        commands.forEach(command => this.nbts.forEach(nbt => nbt.replaceBlock(command)));
        return this
    }

    replaceEntity(command: ReplaceEntityCommand) {
        this.nbts.forEach(nbt => nbt.replaceEntity(command));
        return this;
    }

    replaceEntities(commands: ReplaceEntityCommand[]) {
        commands.forEach(command => this.nbts.forEach(nbt => nbt.replaceEntity(command)));
        return this;
    }

    replaceLootTable(command: ReplaceLootTableCommand) {
        this.nbts.forEach(nbt => nbt.replaceLootTable(command));
        return this;
    }

    replaceLootTables(commands: ReplaceLootTableCommand[]) {
        commands.forEach(command => this.nbts.forEach(nbt => nbt.replaceLootTable(command)));
    }

    removeBiomes() {
        this.structures.forEach(structure => structure.removeBiomes());
        return this;
    }

    onBiomes(biomes: (string | Biome)[]) {
        this.structures.forEach(structure => structure.onBiomes(biomes));
        return this;
    }

    createBlockReplacementMap() {
        const palettes = this.nbts.map(nbt => nbt.exportPalette());
        const map = StructureDefinition.nbtCollectionToMap(palettes);
        const commands: ReplaceBlockCommand[] = [];
        for (const [oldBlock, newBlock] of map) {
            commands.push({oldBlock, newBlock});
        }
        return commands;
    }

    createEntityReplacementMap() {
        const entities = this.nbts.map(nbt => nbt.exportEntities());
        const map = StructureDefinition.nbtCollectionToMap(entities);
        const commands: ReplaceEntityCommand[] = [];
        for (const [oldEntity, newEntity] of map) {
            commands.push({oldEntity, newEntity});
        }
        return commands
    }

    createLootTableReplacementMap() {
        const lootTables = this.nbts.map(nbt => nbt.exportLootTables());
        const map = StructureDefinition.nbtCollectionToMap(lootTables);
        const commands: ReplaceLootTableCommand[] = [];
        for (const [oldLootTable, newLootTable] of map) {
            commands.push({oldLootTable, newLootTable});
        }
        return commands
    }

    private static nbtCollectionToMap(palettes: any[][]) {
        const paletteMap = new Map<string, string>();
        for (const palette of palettes) {
            for (const entry of palette) {
                paletteMap.set(entry, entry);
            }
        }
        return paletteMap;
    }

    async writeSelf() {
        await this.structureSet.writeSelf();
        this.structures.forEach(structure => structure.writeSelf());
        for (const nbt of this.nbts) {
            await nbt.writeSelf();
        }
    }
}

